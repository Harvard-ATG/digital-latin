# Streamlit UI Notes

## App Description (Updated)

This app is a Latin passage simplification assistant for instructors. It uses advanced language models to help Latin teachers simplify authentic classical Latin texts for students at different proficiency levels. The assistant follows detailed, level-specific instructions (from Jinja2 prompt templates) to rewrite Latin passages in a way that preserves all key ideas and context, while removing advanced grammatical structures that may be too difficult for the target student group. The app also provides references to trusted Latin grammar and vocabulary resources.

- **Level I**: Simplifies Latin passages for first-year students, focusing on basic grammar and vocabulary.
- **Level II**: Simplifies Latin passages for second-year students, avoiding advanced constructions and providing more nuanced simplification.

The app allows instructors to:
- Choose the simplification level (Level I or Level II) for their passage.
- Paste or enter a Latin passage and receive a simplified version, following strict pedagogical and grammatical guidelines.
- Review a detailed breakdown of the changes made to each sentence.
- Save, load, and manage past simplification sessions.

## Suggested Sidebar Text

> **Latin Passage Simplifier for Instructors**
>
> Select your simplification level and manage your sessions.  
> Level I and Level II use different sets of grammatical and vocabulary constraints, tailored for first- and second-year Latin students.  
> Paste your Latin passage and receive a simplified version with a detailed breakdown of changes, following best practices for Latin pedagogy.

---

## Components Added

- **Sidebar session management**: 
  - Past sessions are listed with session name and date (date in brackets, padded for alignment).
  - Delete button (trashcan) for each session, with tooltip "Delete Session".
  - Sidebar width increased for better readability.
- **System prompt selection**:
  - Uses Jinja2 templates for system prompts if available (`level1` and `level2`).
  - Falls back to `.md` files or default string if no Jinja template is found.
- **Chat rendering**:
  - User and assistant messages styled with custom backgrounds.
  - Assistant messages support bold (`*word*`) and bullet points (`* ...`).
  - Copy button for assistant messages (uses hidden textarea and JS).
- **Session save/load**:
  - Sessions can be saved and loaded from SQLite DB.
  - Session title and chat history are preserved.

## Challenges & Limitations

- **Streamlit Button Formatting**:
  - `st.button` does not support HTML or true multiline labels.
  - Workaround: pad session names with Unicode spaces and use `\n` to simulate new lines, but rendering is not always perfect.
  - Date is shown in brackets after the session name for clarity.
- **Duplicate Key Errors**:
  - Streamlit requires all widget keys to be unique. 
  - Solution: append `_btn` or similar suffixes to keys for session and delete buttons.
- **HTML in Buttons**:
  - `unsafe_allow_html` is not supported in `st.button`.
  - Tooltips (`help`) are used for extra info.
- **Copy Button for Assistant Messages**:
  - Uses a hidden `<textarea>` and JS to copy text (works in most browsers, but not all environments).
- **Jinja2 Prompt Templates**:
  - Jinja2 templates are loaded dynamically for system prompts.
  - Context can be injected if needed.
  - If no Jinja file is found, falls back to `.md` or default string.
- **Sidebar Layout**:
  - Custom CSS is used to increase sidebar width and improve layout.
  - Some limitations remain due to Streamlit's layout system.
- **Regex and Formatting Issues**:
  - Regex patterns for cleaning up message artifacts (e.g., trailing HTML from button rendering) can cause errors if not carefully escaped.
  - Unescaped parentheses or special characters in regex led to `re.error: unbalanced parenthesis` exceptions.
  - Formatting assistant messages with bold, bullets, and line breaks required repeated tuning.
- **Session List Duplicates**:
  - Accidentally rendering the session list twice in the sidebar led to duplicate session buttons.
  - Solution: ensure only one loop/block renders the session list.
- **Sidebar Session Label Alignment**:
  - Achieving consistent alignment and multiline display for session names and dates is difficult due to Streamlit's widget limitations.
  - Padding with Unicode spaces helps, but is not pixel-perfect and may not work with all fonts.
- **Streamlit Rerun and State Management**:
  - Use of `st.rerun()` to update UI after user input can make state management tricky, especially for chat history and session loading.
  - Ensuring session state is not lost or duplicated after reruns required careful logic.
- **Prompt File Selection**:
  - Ensuring the correct Jinja2 prompt is loaded for each level required filename pattern matching and fallback logic.
  - If multiple prompt files match, only the first is used.
- **Streamlit API Limitations**:
  - Some features (e.g., true multiline button labels, HTML in buttons, custom tooltips) are not natively supported.
  - Workarounds are sometimes brittle or visually inconsistent.

## Limitations of Streamlit Compared to React or JavaScript-Based Applications

- **Customization and Flexibility**: Streamlit is designed for rapid prototyping and data apps, but it is less flexible than React or other JavaScript frameworks for building highly customized UIs and complex interactive components.
- **Component Ecosystem**: React and JavaScript have a vast ecosystem of reusable UI components, libraries, and design systems. Streamlit's component library is limited, and while custom components can be built, it requires extra effort and often involves bridging Python and JavaScript.
- **Frontend Performance**: React apps can leverage advanced frontend optimizations, virtual DOM, and client-side rendering for smoother, more responsive UIs. Streamlit apps are server-driven and can feel less responsive, especially with frequent reruns or large data updates.
- **State Management**: Streamlit's state management is simple but can be limiting for complex workflows. React offers robust state management solutions (Redux, Context API, etc.) for handling complex, multi-component state.
- **Routing and Navigation**: Streamlit has very basic support for multipage apps, while React and JavaScript frameworks offer full-featured routing, nested navigation, and deep linking.
- **Animations and Transitions**: Streamlit has limited support for animations and transitions, whereas React and JavaScript libraries (like Framer Motion) provide rich animation capabilities.
- **Real-Time Collaboration**: Real-time, multi-user collaboration is much easier to implement in JavaScript-based apps using WebSockets or frameworks like Next.js, whereas Streamlit is primarily single-user per session.
- **Mobile Responsiveness**: React and JavaScript frameworks offer fine-grained control over responsive design and mobile optimization. Streamlit apps are responsive to a degree, but customization is limited.
- **Integration with Frontend Tooling**: JavaScript apps can easily integrate with frontend build tools, testing frameworks, and CI/CD pipelines tailored for web development. Streamlit is more focused on Python and data science workflows.

**Summary:** Streamlit is excellent for quickly building data-driven apps in Python, but for highly interactive, visually rich, or large-scale web applications, React or JavaScript-based frameworks offer greater flexibility and control.

## To Do / Ideas

- Improve copy button reliability across all browsers.
- Consider using a custom component for more flexible sidebar layouts.
- Add more dynamic context to Jinja2 prompt rendering if needed.
- Explore better multiline support for session labels in the sidebar.

## UI/UX Tips

### (Optional) Make the Chat Container Narrower

If you want to reduce the width of the main chat container, add this to your app (before rendering chat):

```python
st.markdown("""
<style>
div.st.emotion-cache-1kyxreq, div.st-emotion-cache-1kyxreq, div.st-emotion-cache, div.st-emotion-cache-0 {{
    max-width: 740px !important;
    margin-left: auto !important;
    margin-right: auto !important;
}}
</style>
""", unsafe_allow_html=True)
```

You may need to inspect your app in the browser to find the exact class name for your Streamlit version.

# Notes on Implementation, UI Decisions, and Streamlit Limitations

## Use of st.chat() (or st.chat_message)

As of July 2025, the codebase does **not** use `st.chat()` or `st.chat_message()` from Streamlit. Instead, it manually renders chat history using custom HTML and markdown2. This approach was chosen for full control over formatting and compatibility, but it is more complex and error-prone than using Streamlit's built-in chat components.

## Challenge: Updating the Chat Display with st.rerun()

A major challenge was updating the chat display after user input. Streamlit's `st.rerun()` (formerly `st.experimental_rerun()`) is used to force the script to restart and update the UI. However, due to Streamlit's single-script, top-to-bottom execution model, rerunning the script can make it difficult to manage state transitions and UI updates, especially for chat applications where you want to append messages rather than redraw the entire interface.

## How st.chat_message() Helps

The newer `st.chat_message()` API (sometimes referred to as `st.chat()` in documentation) is designed for chat UIs. It manages message history and incremental updates natively, reducing the need for manual rerun logic and custom HTML. Migrating to this API would simplify the code, make chat updates smoother, and better align with Streamlit's intended usage for conversational apps.

## July 2025: PostgreSQL Integration, DB Sidebar, and Preloaded Data

- **PostgreSQL Integration:**
  - Added support for PostgreSQL as a session backend, with all DB logic encapsulated in `src/session_db_postgres.py`.
  - Docker Compose now includes a PostgreSQL service, with credentials and DB name set via environment variables and `.env` file.
  - Entrypoint script (`entrypoint.sh`) ensures the database is ready, preloads dummy data, and then starts the Streamlit app.
  - Dockerfile now ensures `entrypoint.sh` is executable, automating setup for all contributors.

- **Session Sidebar (DB-Backed):**
  - The sidebar in both main and chatapi apps now loads and displays sessions directly from the PostgreSQL database.
  - File-based session sidebar code is commented out but preserved for future use or fallback.
  - All session management (save, load, delete) is now routed through the DB interface for consistency and production-readiness.

- **Preloaded Dummy Data:**
  - Added `src/load_dummy_sessions.py` to insert example sessions into the PostgreSQL DB for development and testing.
  - Entrypoint script runs this loader automatically on container startup, so the app always starts with sample data in the sidebar.
  - Dummy data is visible in the sidebar and can be loaded into the app for demonstration or testing.

- **Other Notes:**
  - All changes are documented in the README and changelog for team onboarding and transparency.
  - Temporary debug file logging is available in `session_db_postgres.py` to inspect what is being written to the DB (remove before production).

## Database Backend Toggle and Clean UI Architecture (July 2025)

- **Decision:** The application now supports both SQLite and PostgreSQL for session management, with a visual toggle in the Streamlit sidebar. This allows developers and users to switch between database backends at runtime for demonstration, development, or production needs.
- **Implementation:**
  - All database logic is encapsulated in `src/session_db_sqlite.py` and `src/session_db_postgres.py`, each exposing the same interface (e.g., `ensure_sessions_table`, `save_session`, `list_sessions`, `load_session`, `delete_session`).
  - The main Streamlit app files (`streamlit_ui_main.py`, `streamlit_ui_chatapi.py`) do not contain any direct database logic or SQL. Instead, they import the correct backend module based on the sidebar toggle and call its interface functions.
  - The toggle is implemented as a `st.sidebar.radio` widget, making the backend choice explicit and user-friendly.
- **Goal:**
  - Keep the UI code clean, backend-agnostic, and easy to maintain.
  - Enable quick switching and testing of different database backends without code changes or risk of breaking UI logic.
  - Make it easy for future contributors to add new backends or modify existing ones by only touching the backend modules.
- **Benefits:**
  - Facilitates local development (SQLite) and production deployment (PostgreSQL) from the same codebase.
  - Demonstrates best practices for separation of concerns and modularity in Streamlit apps.
  - Reduces risk of bugs and makes the codebase easier to onboard for new developers.

## Accessing PostgreSQL Directly in the Container

To inspect your PostgreSQL database directly from the running container:

1. **Open a shell in the postgres container:**
   ```sh
   docker-compose exec postgres bash
   ```
2. **Connect to PostgreSQL using psql:**
   ```sh
   psql -U $POSTGRES_USER -d $POSTGRES_DB
   # For your setup, typically:
   psql -U postgres -d sessions
   ```
3. **List tables:**
   ```sql
   \dt
   ```
  Output should look like
  sessions=# \dt
          List of relations
 Schema |   Name   | Type  |  Owner   
--------+----------+-------+----------
 public | sessions | table | postgres
(1 row)

4. **View all data in the sessions table:**
   ```sql
   SELECT * FROM sessions;
   ```
5. **To exit psql:**
   ```
   \q
   ```

This is useful for debugging, inspecting data, or running manual queries during development.

## Summary
- The current code uses manual chat rendering, not `st.chat_message()`.
- Updating the chat display with `st.rerun()` works but is clunky and can lead to state management issues.
- Using `st.chat_message()` would be a more robust and maintainable solution for chat UIs in Streamlit.

## Notes on Sentry for Error Handling 

- By default, Sentry **only captures uncaught exceptions** (errors that are not handled by your code and cause a crash or traceback).
- If you use a `try...except` block and catch the exception, **Sentry will NOT capture it automatically** unless you explicitly tell it to.
- To capture caught exceptions with Sentry, add this in your `except` block:
  ```python
  import sentry_sdk

  try:
      # your code
  except Exception as e:
      sentry_sdk.capture_exception(e)
      # your other error handling (e.g., print, log, etc.)
  ```
- **Summary:**  
  - Uncaught exceptions: Sentry captures automatically.
  - Caught exceptions: You must call `sentry_sdk.capture_exception(e)` yourself.
  

## Notes on Logging Integration with Sentry

- By default, Sentry does **not** automatically capture standard Python logging output (e.g., `logging.info`, `logging.error`).
- You **can configure Sentry to capture log messages** by integrating it with Python’s `logging` module.
- This allows Sentry to record log messages as breadcrumbs and send errors as Sentry events.

**How to enable Sentry logging integration:**

```python
import sentry_sdk
import logging
from sentry_sdk.integrations.logging import LoggingIntegration

sentry_logging = LoggingIntegration(
    level=logging.INFO,        # Capture info and above as breadcrumbs
    event_level=log ging.ERROR  # Send errors and above as Sentry events
)

sentry_sdk.init(
    dsn="YOUR_SENTRY_DSN",
    integrations=[sentry_logging]
)
```

- **Breadcrumbs:** Lower-level logs (e.g., `INFO`, `WARNING`) are attached as breadcrumbs to Sentry events.
- **Events:** Logs at `ERROR` level or above are sent as Sentry events.

**Summary:**  
- Sentry does **not** capture logs by default.
- You can enable log capture by adding the logging integration.
- After setup, Sentry will record logs as breadcrumbs and send errors as events.

## Sentry Testing Notes

- Tested Sentry integration with both uncaught and caught exceptions using `1/0` (division by zero).
- Both uncaught and caught errors were successfully recorded in Sentry traces.
- This confirms Sentry is properly capturing all exceptions as expected in this app.

# Section for .notes.md

## Notes on Environment Variables and File Storage

- **SKIP_DB:**  
  Used to disable all database interactions for local development, testing, or fallback scenarios.  
  Set via environment variable (`SKIP_DB=true`).  
  All DB write/read functions check this flag before executing.

- **SESSION_DB_BACKEND:**  
  Allows switching between SQLite and PostgreSQL backends without code changes.  
  Set via environment variable (`SESSION_DB_BACKEND=postgres`).

- **File Storage in Production:**  
  When deployed (e.g., on AWS), any files written by the app (such as debug JSON or session exports) are stored in the container or server's local filesystem.  
  These files are **not** synced back to the Git repository.  
  To access them, you must exec into the running container or use a mounted volume (e.g., EFS or S3 for persistence).
  
## Docker Volumes and Data Deletion

- Running `docker-compose down -v` will stop all containers and **delete all named volumes**, including your Postgres data volume (`pgdata`).
- This will **permanently erase all database data** stored in the volume. Use with caution!
- If you change the Postgres image version (for example, from 16 to 13), you must delete the old volume with `docker-compose down -v` before rebuilding and starting containers. This is because data from a newer Postgres version may not be compatible with an older version.
- After deleting the volume, run `docker-compose up --build` to rebuild and start with a fresh, empty database.

## Notes on JSON Session Data

- **Session Naming:**  
  Currently, all sessions are saved with the name `"Untitled Session"`. This is because the LLM call to generate a session title (using a summary of the passage) has been deactivated for performance and UX reasons. Since users are entering full passages (not just keywords), and to avoid extra LLM calls that slow down responsiveness, session titles are not auto-generated. In the future, a manual or AI-generated title feature could be added.

- **Session ID Handling:**  
  The `session_id` field in the JSON data will be `null` (or omitted) if no record was created in the database (e.g., when `SKIP_DB=true`). Session IDs are generated by the database (as primary keys) when a session is saved to the DB. If the session is not stored in the DB, there will be no `session_id` in the JSON log, making it clear that the session only exists in the file and not in the database.

- **Best Practice:**  
  Document all environment variables in the README for easy onboarding.  
  Use `.env.example` to provide a template for contributors.


# Why use YAML for example_session data?
YAML is used for session data in this project because:
- It is more human-readable and writable than JSON, especially for complex or deeply nested data.
- YAML supports comments, which makes it easier to document the structure and intent of the data directly in the file.
- Multi-line strings and complex objects are easier to represent and edit in YAML.
- It is well-supported in Python and many other languages, making it easy to parse and generate.
- It is ideal for configuration, reference, and example data that may need to be hand-edited or reviewed by humans.


## UI/UX Note on Send Button Responsiveness

- **Intentional Click Required:**
  - A very quick or accidental click on the send button may not always be picked up by Streamlit, especially if the UI is still updating or the button is rapidly enabled/disabled due to reruns.
  - Users should make sure to click the send button intentionally and wait for the UI to respond (e.g., the button disables and "Assistant is thinking..." appears) before clicking again.
  - This is a known limitation of Streamlit's rerun and widget event model, and is not unique to this app.

